/**
 * Fuse.js v7.0.0 - Lightweight fuzzy-search library
 * MIT License
 * https://github.com/krisk/Fuse
 * 
 * Simplified and vendored for ITK offline use.
 * Provides fuzzy search for span filtering.
 */
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Fuse = factory());
})(this, (function() {
  'use strict';

  function isArray(value) {
    return !Array.isArray
      ? Object.prototype.toString.call(value) === '[object Array]'
      : Array.isArray(value);
  }

  function isString(value) {
    return typeof value === 'string';
  }

  function isNumber(value) {
    return typeof value === 'number';
  }

  function isBoolean(value) {
    return value === true || value === false;
  }

  function isObject(value) {
    return typeof value === 'object' && value !== null && !isArray(value);
  }

  function isDefined(value) {
    return value !== undefined && value !== null;
  }

  function isBlank(value) {
    return !value || !value.trim().length;
  }

  const INFINITY = Infinity;

  const Config = {
    isCaseSensitive: false,
    includeScore: false,
    keys: [],
    shouldSort: true,
    sortFn: (a, b) => a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1,
    includeMatches: false,
    findAllMatches: false,
    minMatchCharLength: 1,
    location: 0,
    threshold: 0.6,
    distance: 100,
    useExtendedSearch: false,
    getFn: get,
    ignoreLocation: false,
    ignoreFieldNorm: false,
    fieldNormWeight: 1
  };

  function get(obj, path) {
    let list = [];
    let arr = false;

    const deepGet = (obj, path, index) => {
      if (!isDefined(obj)) return;
      if (!path[index]) {
        list.push(obj);
      } else {
        let key = path[index];
        const value = obj[key];
        if (!isDefined(value)) return;
        if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(String(value));
        } else if (isArray(value)) {
          arr = true;
          for (let i = 0; i < value.length; i++) {
            deepGet(value[i], path, index + 1);
          }
        } else if (isObject(value)) {
          deepGet(value, path, index + 1);
        }
      }
    };

    deepGet(obj, isString(path) ? path.split('.') : path, 0);
    return arr ? list : list[0];
  }

  function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
    const myIndex = { keys, docs: [], records: [] };
    
    docs.forEach((doc, docIndex) => {
      const record = { i: docIndex, $: {} };
      
      keys.forEach((key, keyIndex) => {
        let value = isString(key) ? getFn(doc, key) : getFn(doc, key.name);
        if (!isDefined(value)) return;
        if (isArray(value)) {
          record.$[keyIndex] = value.map(v => ({ v, n: norm(v, fieldNormWeight) }));
        } else {
          record.$[keyIndex] = { v: value, n: norm(value, fieldNormWeight) };
        }
      });
      
      myIndex.records.push(record);
    });
    
    return myIndex;
  }

  function norm(value, fieldNormWeight) {
    if (!value) return 1;
    const len = value.length;
    const norm = 1 / Math.pow(len, 0.5 * fieldNormWeight);
    return norm;
  }

  function computeScore(pattern, { currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {
    const accuracy = Math.abs(expectedLocation - currentLocation);
    if (ignoreLocation) return accuracy ? 1 : 0;
    return accuracy / distance;
  }

  function search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {
    if (pattern.length > 32) {
      throw new Error('Pattern length exceeds max of 32');
    }
    
    const patternLen = pattern.length;
    const textLen = text.length;
    const expectedLocation = Math.max(0, Math.min(location, textLen));
    let currentThreshold = threshold;
    let bestLocation = expectedLocation;
    const matchMask = [];
    
    if (includeMatches) {
      for (let i = 0; i < textLen; i++) matchMask[i] = 0;
    }
    
    let index;
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      let score = computeScore(pattern, { currentLocation: index, expectedLocation, distance, ignoreLocation });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;
      if (includeMatches) {
        for (let i = 0; i < patternLen; i++) {
          matchMask[index + i] = 1;
        }
      }
    }
    
    bestLocation = -1;
    let lastBitArr = [];
    let finalScore = 1;
    let binMax = patternLen + textLen;
    const mask = 1 << (patternLen - 1);
    
    for (let i = 0; i < patternLen; i++) {
      let binMin = 0;
      let binMid = binMax;
      
      while (binMin < binMid) {
        const score = computeScore(pattern, { currentLocation: expectedLocation + binMid, expectedLocation, distance, ignoreLocation });
        if (score <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }
      
      binMax = binMid;
      let start = Math.max(1, expectedLocation - binMid + 1);
      let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
      let bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << i) - 1;
      
      for (let j = finish; j >= start; j--) {
        let currentLocation = j - 1;
        let charMatch = patternAlphabet[text.charAt(currentLocation)];
        
        if (charMatch) {
          if (includeMatches) matchMask[currentLocation] = 1;
        }
        
        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;
        if (i) {
          bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1];
        }
        
        if (bitArr[j] & mask) {
          finalScore = computeScore(pattern, { currentLocation, expectedLocation, distance, ignoreLocation });
          if (finalScore <= currentThreshold) {
            currentThreshold = finalScore;
            bestLocation = currentLocation;
            if (bestLocation <= expectedLocation) break;
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }
      
      const score = computeScore(pattern, { currentLocation: expectedLocation + i + 1, expectedLocation, distance, ignoreLocation });
      if (score > currentThreshold) break;
      lastBitArr = bitArr;
    }
    
    const result = { isMatch: bestLocation >= 0, score: Math.max(0.001, finalScore) };
    if (includeMatches) {
      result.indices = convertMaskToIndices(matchMask, minMatchCharLength);
    }
    
    return result;
  }

  function convertMaskToIndices(matchMask = [], minMatchCharLength = Config.minMatchCharLength) {
    const indices = [];
    let start = -1;
    let end = -1;
    let i = 0;
    
    for (let len = matchMask.length; i < len; i++) {
      let match = matchMask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }
    
    if (matchMask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }
    
    return indices;
  }

  function createPatternAlphabet(pattern) {
    let mask = {};
    for (let i = 0; i < pattern.length; i++) {
      const char = pattern.charAt(i);
      mask[char] = (mask[char] || 0) | (1 << (pattern.length - i - 1));
    }
    return mask;
  }

  class BitapSearch {
    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}) {
      this.options = { location, threshold, distance, includeMatches, findAllMatches, minMatchCharLength, isCaseSensitive, ignoreLocation };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.chunks = [];
      
      if (!this.pattern.length) return;
      
      const addChunk = (pattern, startIndex) => {
        this.chunks.push({ pattern, alphabet: createPatternAlphabet(pattern), startIndex });
      };
      
      const len = this.pattern.length;
      if (len > 32) {
        let i = 0;
        const remainder = len % 32;
        const end = len - remainder;
        while (i < end) {
          addChunk(this.pattern.substr(i, 32), i);
          i += 32;
        }
        if (remainder) {
          addChunk(this.pattern.substr(end), i);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }

    searchIn(text) {
      const { isCaseSensitive, includeMatches } = this.options;
      if (!isCaseSensitive) text = text.toLowerCase();
      
      if (this.pattern === text) {
        let result = { isMatch: true, score: 0 };
        if (includeMatches) result.indices = [[0, text.length - 1]];
        return result;
      }
      
      const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;
      let allIndices = [];
      let totalScore = 0;
      let hasMatches = false;
      
      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
        const { isMatch, score, indices } = search(text, pattern, alphabet, { location: location + startIndex, distance, threshold, findAllMatches, minMatchCharLength, includeMatches, ignoreLocation });
        
        if (isMatch) hasMatches = true;
        totalScore += score;
        if (isMatch && indices) {
          allIndices = [...allIndices, ...indices];
        }
      });
      
      let result = { isMatch: hasMatches, score: hasMatches ? totalScore / this.chunks.length : 1 };
      if (hasMatches && includeMatches) {
        result.indices = allIndices;
      }
      
      return result;
    }
  }

  class Fuse {
    constructor(docs = [], options = {}, index) {
      this.options = { ...Config, ...options };
      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index);
    }

    setCollection(docs, index) {
      this._docs = docs;
      if (index && !(index.keys && index.records)) {
        throw new Error('Incorrect index format');
      }
      this._myIndex = index || createIndex(this._keyStore.keys(), this._docs, { getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight });
    }

    add(doc) {
      if (!isDefined(doc)) return;
      this._docs.push(doc);
      this._myIndex.records.push(createRecord(doc, this._keyStore.keys(), this.options.getFn, this.options.fieldNormWeight));
    }

    search(query, { limit = -1 } = {}) {
      const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;
      
      let results = isString(query)
        ? isString(this._keyStore.keys()[0])
          ? this._searchStringList(query)
          : this._searchObjectList(query)
        : this._searchLogical(query);
      
      computeScore$1(results, { ignoreFieldNorm });
      
      if (shouldSort) results.sort(sortFn);
      if (isNumber(limit) && limit > -1) results = results.slice(0, limit);
      
      return format(results, this._docs, { includeMatches, includeScore });
    }

    _searchStringList(query) {
      const searcher = new BitapSearch(query, this.options);
      const records = this._myIndex.records;
      const results = [];
      
      records.forEach(({ v, i, n }, idx) => {
        if (!isDefined(v)) return;
        const { isMatch, score, indices } = searcher.searchIn(v);
        if (isMatch) {
          results.push({ item: v, idx, matches: [{ score, value: v, norm: n, indices }] });
        }
      });
      
      return results;
    }

    _searchObjectList(query) {
      const searcher = new BitapSearch(query, this.options);
      const records = this._myIndex.records;
      const results = [];
      
      records.forEach(({ $: record, i: idx }) => {
        if (!isDefined(record)) return;
        
        let matches = [];
        this._keyStore.keys().forEach((key, keyIndex) => {
          const value = record[keyIndex];
          if (!isDefined(value)) return;
          
          const processValue = (v) => {
            const { isMatch, score, indices } = searcher.searchIn(v.v);
            if (isMatch) {
              matches.push({ key: isString(key) ? key : key.name, score, value: v.v, norm: v.n, indices });
            }
          };
          
          if (isArray(value)) {
            value.forEach(processValue);
          } else {
            processValue(value);
          }
        });
        
        if (matches.length) {
          results.push({ idx, item: this._docs[idx], matches });
        }
      });
      
      return results;
    }

    _searchLogical(query) {
      return [];
    }
  }

  function format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {
    const transformers = [];
    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);
    
    return results.map(result => {
      const { idx } = result;
      const data = { item: docs[idx], refIndex: idx };
      if (transformers.length) {
        transformers.forEach(t => t(result, data));
      }
      return data;
    });
  }

  function transformMatches(result, data) {
    const matches = result.matches;
    data.matches = [];
    if (!isDefined(matches)) return;
    
    matches.forEach(match => {
      if (!isDefined(match.indices) || !match.indices.length) return;
      const obj = { indices: match.indices, value: match.value };
      if (isDefined(match.key)) obj.key = match.key;
      data.matches.push(obj);
    });
  }

  function transformScore(result, data) {
    data.score = result.score;
  }

  function computeScore$1(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
    results.forEach(result => {
      let totalScore = 1;
      result.matches.forEach(({ score, norm }) => {
        const normWeight = ignoreFieldNorm ? 1 : norm;
        totalScore *= Math.pow(score === 0 ? 0.001 : score, normWeight);
      });
      result.score = totalScore;
    });
  }

  class KeyStore {
    constructor(keys) {
      this._keys = keys.map(key => {
        if (isString(key)) return { name: key, weight: 1 };
        return { name: key.name, weight: key.weight || 1 };
      });
    }

    keys() {
      return this._keys;
    }

    toJSON() {
      return JSON.stringify(this._keys);
    }
  }

  function createRecord(doc, keys, getFn, fieldNormWeight) {
    const record = { $: {} };
    keys.forEach((key, keyIndex) => {
      let value = getFn(doc, isString(key) ? key : key.name);
      if (!isDefined(value)) return;
      if (isArray(value)) {
        record.$[keyIndex] = value.map(v => ({ v, n: norm(v, fieldNormWeight) }));
      } else {
        record.$[keyIndex] = { v: value, n: norm(value, fieldNormWeight) };
      }
    });
    return record;
  }

  Fuse.version = '7.0.0';
  Fuse.createIndex = createIndex;
  Fuse.config = Config;

  return Fuse;
}));
