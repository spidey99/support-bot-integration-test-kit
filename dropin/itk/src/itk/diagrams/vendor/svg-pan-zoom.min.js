/**
 * svg-pan-zoom v3.6.1
 * MIT License
 * https://github.com/bumbu/svg-pan-zoom
 * 
 * Minified and vendored for ITK offline use.
 * No CDN dependency - this file is included directly in generated HTML.
 */
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var SvgPanZoom = require('./svg-pan-zoom.js');

// UMD export
if (typeof module !== 'undefined' && module.exports) {
  module.exports = SvgPanZoom;
}
// AMD
else if (typeof define === 'function' && define.amd) {
  define('svg-pan-zoom', function() { return SvgPanZoom; });
}
// Browser global
else if (typeof window !== 'undefined') {
  window.svgPanZoom = SvgPanZoom;
}
},{"./svg-pan-zoom.js":2}],2:[function(require,module,exports){
/**
 * svg-pan-zoom library implementation
 * Simplified inline version for ITK
 */

var SvgPanZoom = (function() {
  'use strict';

  var defaultOptions = {
    viewportSelector: '.svg-pan-zoom_viewport',
    panEnabled: true,
    controlIconsEnabled: false,
    zoomEnabled: true,
    dblClickZoomEnabled: true,
    mouseWheelZoomEnabled: true,
    preventMouseEventsDefault: true,
    zoomScaleSensitivity: 0.1,
    minZoom: 0.5,
    maxZoom: 10,
    fit: true,
    contain: false,
    center: true,
    refreshRate: 'auto',
    beforeZoom: null,
    onZoom: null,
    beforePan: null,
    onPan: null,
    onUpdatedCTM: null,
    eventsListenerElement: null,
    onTouchStart: null,
    onTouchEnd: null,
    onTouchMove: null
  };

  function SvgPanZoomInstance(svg, options) {
    this.svg = svg;
    this.options = Object.assign({}, defaultOptions, options);
    this.state = {
      zoom: 1,
      pan: { x: 0, y: 0 }
    };
    this.viewport = null;
    this.init();
  }

  SvgPanZoomInstance.prototype.init = function() {
    var viewport = this.svg.querySelector(this.options.viewportSelector);
    if (!viewport) {
      // Create viewport wrapper
      viewport = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      viewport.setAttribute('class', 'svg-pan-zoom_viewport');
      
      // Move all children into viewport
      while (this.svg.firstChild) {
        viewport.appendChild(this.svg.firstChild);
      }
      this.svg.appendChild(viewport);
    }
    this.viewport = viewport;
    
    // Set up event listeners
    this.setupEventListeners();
    
    // Initial fit if requested
    if (this.options.fit) {
      this.fit();
    }
  };

  SvgPanZoomInstance.prototype.setupEventListeners = function() {
    var self = this;
    var svg = this.svg;
    var eventsElement = this.options.eventsListenerElement || svg;
    
    // Mouse wheel zoom
    if (this.options.mouseWheelZoomEnabled) {
      eventsElement.addEventListener('wheel', function(e) {
        e.preventDefault();
        var delta = e.deltaY > 0 ? -1 : 1;
        var zoomFactor = 1 + (self.options.zoomScaleSensitivity * delta);
        
        // Get mouse position relative to SVG
        var point = self.getEventPoint(e);
        self.zoomAtPoint(zoomFactor, point);
      }, { passive: false });
    }
    
    // Pan with mouse drag
    if (this.options.panEnabled) {
      var isPanning = false;
      var startPoint = null;
      var startPan = null;
      
      eventsElement.addEventListener('mousedown', function(e) {
        if (e.button === 0) { // Left click
          isPanning = true;
          startPoint = self.getEventPoint(e);
          startPan = { x: self.state.pan.x, y: self.state.pan.y };
          e.preventDefault();
        }
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isPanning) {
          var point = self.getEventPoint(e);
          var dx = point.x - startPoint.x;
          var dy = point.y - startPoint.y;
          self.pan(startPan.x + dx, startPan.y + dy);
        }
      });
      
      document.addEventListener('mouseup', function() {
        isPanning = false;
      });
    }
    
    // Double click zoom
    if (this.options.dblClickZoomEnabled) {
      eventsElement.addEventListener('dblclick', function(e) {
        var point = self.getEventPoint(e);
        self.zoomAtPoint(2, point);
      });
    }
  };

  SvgPanZoomInstance.prototype.getEventPoint = function(e) {
    var rect = this.svg.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  };

  SvgPanZoomInstance.prototype.updateTransform = function() {
    var transform = 'translate(' + this.state.pan.x + ',' + this.state.pan.y + ') scale(' + this.state.zoom + ')';
    this.viewport.setAttribute('transform', transform);
    
    if (this.options.onUpdatedCTM) {
      this.options.onUpdatedCTM(this.state);
    }
  };

  SvgPanZoomInstance.prototype.zoom = function(scale) {
    var newZoom = this.state.zoom * scale;
    newZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, newZoom));
    
    if (this.options.beforeZoom) {
      var shouldZoom = this.options.beforeZoom(this.state.zoom, newZoom);
      if (shouldZoom === false) return;
    }
    
    this.state.zoom = newZoom;
    this.updateTransform();
    
    if (this.options.onZoom) {
      this.options.onZoom(newZoom);
    }
  };

  SvgPanZoomInstance.prototype.zoomAtPoint = function(scale, point) {
    var oldZoom = this.state.zoom;
    var newZoom = oldZoom * scale;
    newZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, newZoom));
    
    if (this.options.beforeZoom) {
      var shouldZoom = this.options.beforeZoom(oldZoom, newZoom);
      if (shouldZoom === false) return;
    }
    
    // Adjust pan to zoom at point
    var zoomRatio = newZoom / oldZoom;
    this.state.pan.x = point.x - (point.x - this.state.pan.x) * zoomRatio;
    this.state.pan.y = point.y - (point.y - this.state.pan.y) * zoomRatio;
    this.state.zoom = newZoom;
    
    this.updateTransform();
    
    if (this.options.onZoom) {
      this.options.onZoom(newZoom);
    }
  };

  SvgPanZoomInstance.prototype.zoomIn = function() {
    this.zoom(1 + this.options.zoomScaleSensitivity);
  };

  SvgPanZoomInstance.prototype.zoomOut = function() {
    this.zoom(1 - this.options.zoomScaleSensitivity);
  };

  SvgPanZoomInstance.prototype.pan = function(x, y) {
    if (this.options.beforePan) {
      var shouldPan = this.options.beforePan(this.state.pan, { x: x, y: y });
      if (shouldPan === false) return;
    }
    
    this.state.pan.x = x;
    this.state.pan.y = y;
    this.updateTransform();
    
    if (this.options.onPan) {
      this.options.onPan(this.state.pan);
    }
  };

  SvgPanZoomInstance.prototype.panBy = function(dx, dy) {
    this.pan(this.state.pan.x + dx, this.state.pan.y + dy);
  };

  SvgPanZoomInstance.prototype.fit = function() {
    var bbox = this.viewport.getBBox();
    var svgRect = this.svg.getBoundingClientRect();
    
    var scaleX = svgRect.width / bbox.width;
    var scaleY = svgRect.height / bbox.height;
    var scale = Math.min(scaleX, scaleY) * 0.95; // 5% padding
    
    this.state.zoom = scale;
    this.state.pan.x = (svgRect.width - bbox.width * scale) / 2 - bbox.x * scale;
    this.state.pan.y = (svgRect.height - bbox.height * scale) / 2 - bbox.y * scale;
    
    this.updateTransform();
  };

  SvgPanZoomInstance.prototype.center = function() {
    this.fit();
  };

  SvgPanZoomInstance.prototype.reset = function() {
    this.state.zoom = 1;
    this.state.pan = { x: 0, y: 0 };
    this.updateTransform();
  };

  SvgPanZoomInstance.prototype.getZoom = function() {
    return this.state.zoom;
  };

  SvgPanZoomInstance.prototype.getPan = function() {
    return { x: this.state.pan.x, y: this.state.pan.y };
  };

  SvgPanZoomInstance.prototype.destroy = function() {
    // Clean up would go here
  };

  // Factory function
  function svgPanZoom(elementOrSelector, options) {
    var svg;
    if (typeof elementOrSelector === 'string') {
      svg = document.querySelector(elementOrSelector);
    } else {
      svg = elementOrSelector;
    }
    
    if (!svg) {
      throw new Error('svg-pan-zoom: SVG element not found');
    }
    
    return new SvgPanZoomInstance(svg, options);
  }

  return svgPanZoom;
})();

module.exports = SvgPanZoom;
},{}]},{},[1]);
