/**
 * svg-pan-zoom - Lightweight SVG pan/zoom library
 * Simplified browser-only version for ITK offline use.
 * No CommonJS/AMD - just a browser global.
 */
(function(window) {
  'use strict';

  var defaultOptions = {
    viewportSelector: '.svg-pan-zoom_viewport',
    panEnabled: true,
    controlIconsEnabled: false,
    zoomEnabled: true,
    dblClickZoomEnabled: true,
    mouseWheelZoomEnabled: true,
    preventMouseEventsDefault: true,
    zoomScaleSensitivity: 0.2,
    minZoom: 0.1,
    maxZoom: 20,
    fit: true,
    contain: false,
    center: true,
    beforeZoom: null,
    onZoom: null,
    beforePan: null,
    onPan: null,
    onUpdatedCTM: null
  };

  function SvgPanZoomInstance(svg, options) {
    this.svg = svg;
    this.options = Object.assign({}, defaultOptions, options);
    this.state = {
      zoom: 1,
      pan: { x: 0, y: 0 }
    };
    this.viewport = null;
    this.init();
  }

  SvgPanZoomInstance.prototype.init = function() {
    var self = this;
    var viewport = this.svg.querySelector(this.options.viewportSelector);
    
    if (!viewport) {
      // Create viewport wrapper if not exists
      viewport = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      viewport.setAttribute('class', 'svg-pan-zoom_viewport');
      
      // Move all children into viewport
      while (this.svg.firstChild) {
        viewport.appendChild(this.svg.firstChild);
      }
      this.svg.appendChild(viewport);
    }
    this.viewport = viewport;
    
    // Set up event listeners
    this.setupEventListeners();
    
    // Initial fit if requested
    if (this.options.fit) {
      // Defer fit to ensure SVG is rendered
      setTimeout(function() { self.fit(); }, 0);
    }
  };

  SvgPanZoomInstance.prototype.setupEventListeners = function() {
    var self = this;
    var svg = this.svg;
    
    // Mouse wheel zoom
    if (this.options.mouseWheelZoomEnabled) {
      svg.addEventListener('wheel', function(e) {
        e.preventDefault();
        var delta = e.deltaY > 0 ? -1 : 1;
        var zoomFactor = 1 + (self.options.zoomScaleSensitivity * delta);
        var point = self.getEventPoint(e);
        self.zoomAtPoint(zoomFactor, point);
      }, { passive: false });
    }
    
    // Pan with mouse drag - only on empty areas
    if (this.options.panEnabled) {
      var isPanning = false;
      var startPoint = null;
      var startPan = null;
      
      svg.addEventListener('mousedown', function(e) {
        // Only pan on left click and NOT on interactive elements like .message
        var isInteractive = e.target.closest('.message, .participant, button, a, [role="button"]');
        if (e.button === 0 && !isInteractive) {
          isPanning = true;
          startPoint = self.getEventPoint(e);
          startPan = { x: self.state.pan.x, y: self.state.pan.y };
          svg.style.cursor = 'grabbing';
          e.preventDefault();
          e.stopPropagation();
        }
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isPanning && startPoint) {
          var point = self.getEventPoint(e);
          var dx = point.x - startPoint.x;
          var dy = point.y - startPoint.y;
          self.pan(startPan.x + dx, startPan.y + dy);
        }
      });
      
      document.addEventListener('mouseup', function() {
        if (isPanning) {
          isPanning = false;
          svg.style.cursor = 'grab';
        }
      });
    }
    
    // Double click zoom - only on empty areas
    if (this.options.dblClickZoomEnabled) {
      svg.addEventListener('dblclick', function(e) {
        var isInteractive = e.target.closest('.message, .participant, button, a, [role="button"]');
        if (!isInteractive) {
          var point = self.getEventPoint(e);
          self.zoomAtPoint(2, point);
        }
      });
    }
  };

  SvgPanZoomInstance.prototype.getEventPoint = function(e) {
    var rect = this.svg.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  };

  SvgPanZoomInstance.prototype.updateTransform = function() {
    var transform = 'translate(' + this.state.pan.x + ',' + this.state.pan.y + ') scale(' + this.state.zoom + ')';
    this.viewport.setAttribute('transform', transform);
    
    if (this.options.onUpdatedCTM) {
      this.options.onUpdatedCTM(this.state);
    }
  };

  SvgPanZoomInstance.prototype.zoom = function(scale) {
    var newZoom = this.state.zoom * scale;
    newZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, newZoom));
    
    if (this.options.beforeZoom) {
      var shouldZoom = this.options.beforeZoom(this.state.zoom, newZoom);
      if (shouldZoom === false) return;
    }
    
    this.state.zoom = newZoom;
    this.updateTransform();
    
    if (this.options.onZoom) {
      this.options.onZoom(newZoom);
    }
  };

  SvgPanZoomInstance.prototype.zoomAtPoint = function(scale, point) {
    var oldZoom = this.state.zoom;
    var newZoom = oldZoom * scale;
    newZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, newZoom));
    
    if (this.options.beforeZoom) {
      var shouldZoom = this.options.beforeZoom(oldZoom, newZoom);
      if (shouldZoom === false) return;
    }
    
    // Adjust pan to zoom at point
    var zoomRatio = newZoom / oldZoom;
    this.state.pan.x = point.x - (point.x - this.state.pan.x) * zoomRatio;
    this.state.pan.y = point.y - (point.y - this.state.pan.y) * zoomRatio;
    this.state.zoom = newZoom;
    
    this.updateTransform();
    
    if (this.options.onZoom) {
      this.options.onZoom(newZoom);
    }
  };

  SvgPanZoomInstance.prototype.zoomIn = function() {
    this.zoom(1 + this.options.zoomScaleSensitivity);
  };

  SvgPanZoomInstance.prototype.zoomOut = function() {
    this.zoom(1 - this.options.zoomScaleSensitivity);
  };

  SvgPanZoomInstance.prototype.pan = function(x, y) {
    if (this.options.beforePan) {
      var shouldPan = this.options.beforePan(this.state.pan, { x: x, y: y });
      if (shouldPan === false) return;
    }
    
    this.state.pan.x = x;
    this.state.pan.y = y;
    this.updateTransform();
    
    if (this.options.onPan) {
      this.options.onPan(this.state.pan);
    }
  };

  SvgPanZoomInstance.prototype.panBy = function(dx, dy) {
    this.pan(this.state.pan.x + dx, this.state.pan.y + dy);
  };

  SvgPanZoomInstance.prototype.fit = function() {
    var bbox = this.viewport.getBBox();
    var svgRect = this.svg.getBoundingClientRect();
    
    if (bbox.width === 0 || bbox.height === 0 || svgRect.width === 0 || svgRect.height === 0) {
      return; // Can't fit if no size
    }
    
    var scaleX = svgRect.width / bbox.width;
    var scaleY = svgRect.height / bbox.height;
    var scale = Math.min(scaleX, scaleY) * 0.9; // 10% padding
    
    this.state.zoom = scale;
    this.state.pan.x = (svgRect.width - bbox.width * scale) / 2 - bbox.x * scale;
    this.state.pan.y = (svgRect.height - bbox.height * scale) / 2 - bbox.y * scale;
    
    this.updateTransform();
  };

  SvgPanZoomInstance.prototype.center = function() {
    this.fit();
  };

  SvgPanZoomInstance.prototype.reset = function() {
    this.state.zoom = 1;
    this.state.pan = { x: 0, y: 0 };
    this.updateTransform();
  };

  SvgPanZoomInstance.prototype.getZoom = function() {
    return this.state.zoom;
  };

  SvgPanZoomInstance.prototype.getPan = function() {
    return { x: this.state.pan.x, y: this.state.pan.y };
  };

  SvgPanZoomInstance.prototype.destroy = function() {
    // Clean up would go here if needed
  };

  // Factory function
  function svgPanZoom(elementOrSelector, options) {
    var svg;
    if (typeof elementOrSelector === 'string') {
      svg = document.querySelector(elementOrSelector);
    } else {
      svg = elementOrSelector;
    }
    
    if (!svg) {
      console.error('svg-pan-zoom: SVG element not found:', elementOrSelector);
      return null;
    }
    
    return new SvgPanZoomInstance(svg, options);
  }

  // Export as browser global
  window.svgPanZoom = svgPanZoom;

})(window);
